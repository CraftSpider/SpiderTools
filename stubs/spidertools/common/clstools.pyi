
from typing import Callable, Any, TypeVar, Optional, Tuple, Dict, FrozenSet, Union, Iterable, List, Set


_T = TypeVar("_T")
_V = TypeVar("_V")


def _mangle(cls: type, name: str) -> str: ...

def unwrap(func: Callable[[Any], Any]) -> Callable[[Any], Any]: ...

def forward_func(new: Callable[[Any], Any], old: Callable[[Any], Any]) -> None: ...

def forward_class(new: type, old: type) -> None: ...

class Singleton:

    def __new__(cls, *args: Any, **kwargs: Any) -> 'Singleton': ...

    def __init_subclass__(cls, **kwargs: Any) -> None: ...

def decorator(func: Callable[[_T], _V]) -> Callable[[_T], _V]: ...

def noarg_decorator(func: Callable[[_T], _V]) -> Callable[[_T], _V]: ...

_caches: Dict[Callable[[Any], Any], Any] = ...

def _make_unique(key: Union[int, str], val: Any) -> Tuple[Union[int, str], Any]: ...

def _make_key(args: Any, kwargs: Any) -> FrozenSet[Tuple[Union[int, str], Any]]: ...

def invalidating_cache(*, method: bool = ...) -> Callable[[Any], Any]: ...

def _check_cache(to_check: Iterable[Union[int, str]], args: Union[List[Any], Dict[str, Any]], cache: Dict[FrozenSet[Any], Any], generic: bool) -> Set[FrozenSet[Any]]: ...

def cache_invalidator(*, func: Optional[Callable[[Any], Any]] = ..., method: bool = ..., args: Optional[Tuple[int, ...]] = ..., kwargs: Optional[Tuple[str, ...]] = ...) -> Callable[[Any], Any]: ...
