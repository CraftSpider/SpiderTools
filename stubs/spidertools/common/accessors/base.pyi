
import abc

from typing import Tuple, Any, Iterable, List, Optional, Union, Dict


_Sql = Union[str, int, bool]


ConnectionLost: object = ...


class EmptyCursor:

    __slots__ = ()

    DEFAULT_ONE: None = ...
    DEFAULT_ALL: list = ...

    # noinspection PyMissingConstructor
    def __init__(self) -> None: ...

    def __iter__(self) -> iter: ...

    @property
    def description(self) -> Tuple: return ...
    @property
    def rowcount(self) -> int: return ...
    @property
    def lastrowid(self) -> type(None): return ...

    def callproc(self, procname: str, args: Tuple[Any, ...] = ...) -> None: ...

    def close(self) -> None: ...

    def execute(self, query: str, params: Iterable = ..., multi: bool = ...) -> None: ...

    def executemany(self, operation: str, seqparams: Iterable[Iterable]) -> None: ...

    def fetchone(self) -> type(DEFAULT_ONE): ...

    def fetchmany(self, size: int = ...) -> type(DEFAULT_ALL): ...

    def fetchall(self) -> type(DEFAULT_ALL): ...

class DatabaseAccessor(abc.ABC):

    __slots__ = ("_connection", "_cursor")

    _connection: Any
    _cursor: Any

    def __init__(self) -> None: ...

    @abc.abstractmethod
    def create_connection(self, *, user: str, password: str, host: str, port: int, schema: str, autocommit: bool) -> None: ...

    @abc.abstractmethod
    def execute(self, query: str, params: Optional[Union[List[_Sql], Dict[str, _Sql]]] = ..., multi: bool = ...) -> None: ...

    @abc.abstractmethod
    def get_schemata(self) -> List[Tuple[_Sql, ...]]: ...

    @abc.abstractmethod
    def current_schema(self) -> Optional[str]: ...

    @abc.abstractmethod
    def create_schema(self, schema: str) -> None: ...

    @abc.abstractmethod
    def has_schema(self, schema: str) -> bool: ...

    @abc.abstractmethod
    def create_table(self, name: str, columns: List[Dict[str, _Sql]], primary_keys: Optional[List[str]] = ..., foreign_keys: Optional[List[Dict[str, str]]] = ...) -> None: ...

    @abc.abstractmethod
    def get_tables(self) -> List[Tuple[_Sql, ...]]: ...

    @abc.abstractmethod
    def has_table(self, name: str) -> bool: ...

    @abc.abstractmethod
    def drop_table(self, name: str) -> None: ...

    @abc.abstractmethod
    def add_column(self, table: str, column: Dict[str, _Sql], *, after: Optional[str] = ...) -> None: ...

    @abc.abstractmethod
    def get_columns(self, table: str) -> List[Tuple[_Sql, ...]]: ...

    @abc.abstractmethod
    def has_column(self, table: str, column: str) -> bool: ...

    @abc.abstractmethod
    def alter_column(self, table: str, column: Dict[str, _Sql]) -> None: ...

    @abc.abstractmethod
    def drop_column(self, table: str, column: str) -> None: ...

    @abc.abstractmethod
    def insert(self, table: str, *, values: List[_Sql], names: Optional[List[str]] = ..., update: bool = ...) -> None: ...

    @abc.abstractmethod
    def count(self, table: str, *, where: str, params: Optional[Union[List[_Sql], Dict[str, _Sql]]] = ..., limit: Optional[str] = ...) -> int: ...

    @abc.abstractmethod
    def select(self, table: str, *, where: str, params: Optional[Union[List[_Sql], Dict[str, _Sql]]] = ..., order: Optional[str] = ..., limit: Optional[str] = ...) -> List[Tuple[_Sql, ...]]: ...

    @abc.abstractmethod
    def delete(self, table: str, *, where: str, params: Optional[Union[List[_Sql], Dict[str, _Sql]]] = ..., order: Optional[str] = ..., limit: Optional[str] = ...) -> None: ...

    @abc.abstractmethod
    def create_trigger(self, name: str, cause: str, table: str, for_each: str, text: str) -> None: ...

    @abc.abstractmethod
    def get_triggers(self) -> List[Tuple[_Sql, ...]]: ...

    @abc.abstractmethod
    def drop_trigger(self, trigger: str) -> None: ...

    def is_connected(self) -> bool: ...

    def close(self) -> None: ...
